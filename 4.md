# 引用
## 基本概念
* 共享引用&T只读不可写，任意时刻可以有多个，copy type。只要存在共享引用，连所有者都不能修改它。
* 可变引用&mut T可读可写，同一时刻最多只能有一个，no-copy type。只要存在可变引用，连所有者都无法访问
* 保证了读写的严格隔离，对内存安全性的基础作用。
## 常识
* .操作符具有一定的智能性，对引用可以自动dereference，对非引用可以自动reference。甚至还会沿着引用链搜索到底（看穿），比较操作符也可以看穿，但要求两边必须类型相同（同级引用）
* let mut r = &x; 表示可以改变r所引用的地址，但不可以通过该引用改变x的内容（C++的引用不可以改变地址）
* 看穿比较和不看穿比较：r1==r2 与 std::ptr::eq(r1, r2)
* Rust支持在任意表达式上创建引用，程序会创建一个隐式的变量来存放表达式的值并维护生存期
* slice:[T]长度在编译时不确定，它不能直接创建，不能存到变量中，而是排布在内存中被指向；对slice的引用:&[T]才是长度确定的，是一个fat pointer包含地址和数量
* 宏以引用的方式解析参数，不会造成所有权转移
## 生存期
* 为了保证安全性，编译器设定了一组约束：每一个【变量或值】都有一个Lifetime，对应程序的一个区域，在区域中使用变量是安全的。如果所有Lifetime约束都能满足，则程序是安全的。Lifetime是编译时的概念。
* 对于变量的生存期是在代码中已经包含的，而对于引用的生存期则需要推断或指定！
* 约束1：LT(x)>=LT(&x)
* 约束2：r=&x，则LT(&x)>=LT(r)
* 这种约束对C/C++也适用，但C/C++编译器不作检查，而是交给程序员
* 全局变量static，生存期和整个程序相同，不代表全局可见性，必须初始化。可变全局变量天然具有安全问题，只能在unsafe代码块中访问。
* 由于lifetime概念的引入，在代码中也需要拓展内容：函数引入生命期参数<'a>/<'static>（注意是可能用到的参数的生命期参数，而不是函数自身的生命期）；变量引入&'a和&'static生命期关键字。
    ```Rust
    static mut STASH = &128;
    fn f<'a>(p : &'a i32)
    {unsafe{STASH = p;}}//会报错，不能总是满足lT(p)>=LT(STASH)
    ```
* 函数返回引用：如果函数只有一个参数且它为引用，只有一个返回值且是引用类型，没有声明lifetime参数。那么，Rust默认：参数与返回值具有相同lifetime
* struct包含引用：如果struct中包含引用，需要为引用类型的分量声明lifetime
* 函数签名中，可以不显式声明lifetime，编译器会自动尝试添加合适的lifetime。最简单的情况，为每个引用声明一个独立的lifetime参数
* 推断规则：如果函数的所有参数只涉及一个lifetime，则默认所有lifetime相同；如果函数的参数有多个lifetime参数，则必须声明返回值的lifetime；如果函数是附着在struct上的一个方法且具有参数&self，那么返回值的lifetime和self的相同。
* 也可以随时显式声明lifetime
* Rust编译器在计算一个引用的lifetime的时候，会取满足条件的尽可能小的值（以便扩展或推导？）
## 引用的安全性
* 对一个只读引用，以它为根的所有权关系树都是只读的；对一个可变引用，以它为根的所有权关系树都是排他的
* 特点是把内存引用关系从图变成树，丢失了很多灵活性，但增加了可分析性
* 所有权不包含可变性！转移所有权的时候，可以改变可变性
## 四种指针
1. let p: &i32 = &a;
2. let p: &mut i32 = &mut a;
3. let mut p: &i32 = &a;
4. let mut p: &mut i32 = &mut a;
5. Box类型的pointer则没有这四种形式，要么不加mut声明就都不可变，要么加mut声明就都可变。不存在栈值可变堆值不可变的情况（依赖）；没必要设计栈值不变堆值可变的情况（干脆用mut）
6. 拥有所有权的栈值不变、堆值可变设计：使用字面量创建的可变引用
```Rust
    let p = &mut 0; // 不能修改栈值
    *p = 1;         // 可以修改堆值
    let p = &mut String::from("Hello");
    p.push_str(" world");
    let p = &mut *Box::new(0);
    *p = 1;
```
## 补充
* 屏蔽机制没有消除原有变量（生存期），只是屏蔽了访问方式。不会使其上的引用失效，仍能通过旧的引用访问到
```Rust
    let s = String::from("a");
    let r = &s;
    let s = 42;
    println!("{}, {}", r, s); //输出a, 42 
```
* 常量可能是存放在静态数据区里的，生命期和程序相同
* 引用函数的返回值时，这个隐式变量是存放在栈中的