# 例题解析
1. usize和isize的实质都用于表示地址，在Rust中用以表示引用、索引和长度。usize用在绝对地址，而isize用于偏移量（其实是一样的）。
2. 理论上说用1bit的信息量就能定义bool了，我们也可以自定义一个bitset确实只用1bit保存一个bool。但结合到硬件实现上，内存寻址是按Byte来的，更小粒度的变量不方便寻址。相比之下，内存的浪费显得并不显著。
3. & / &mut。共享引用可读不可写，可以同时存在多个；可变引用可写可读，同时只能存在一个。
4. 所有权是变量对其所拥有值的唯一管理权限，当绑定时成为所有者。整数是copy的，没有所有权转移；向量是非copy的，会发生所有权转移，在栈中的值被转移，但堆中的值不会改变。
5. as_mut()/mut并clone + 覆盖
6. 栈和堆
7. 
    ```Rust
    struct Person{name:String, age:u32,} 和 struct Point(i32, i32);
    ```
    都没有规定。一般而言namefield按字段顺序，tuplelike按顺序
8. std::ptr::eq
9. 数组、切片等动态大小的类型的引用除了地址之外还需要长度等信息
10. 自动ref or deref
11. 隐式变量，声明周期就是表达式所在的作用域
12. 内存安全性，避免悬空引用
13. 代码可读性下降
14. 锁定了构建过程中依赖的版本，保证稳定性
15. 数组默认是在栈中的，release模式会作一定的优化，可能生成到堆中去了
16. TODO
17. Cell<T>只能包含copy类型，RefCell则可以包含任何类型。效果是提供内部可变性，实现动态借用——在编译时无法确定的情况下，在运行时
18. 内存安全性、函数式编程、零成本抽象、并发安全
19. 增加异步编程的特性。这比较复杂，对编译器提出了很高的要求
20. 