# 所有权和所有权转移
## 基本概念
* 在任意时刻，一个值只有唯一一个所有者；每个变量作为根节点，出现在一颗所有权关系树中；当一个变量离开当前作用域后，它所有权关系树的所有值都无法再被访问，其中所有堆中的值会自动被释放。
* 所有权转移：一个值的所有权可以被转移给其他所有者
* 简单变量豁免：对于具有简单类型的变量（整数、浮点数、字符等），所有权规则不适用。这些类型为Copy types
* 引用计数指针类型：允许一个值具有多个所有者，但存在限制
* borrow a ref to a value: 可以在不改变所有权的情况下，通过引用访问值
## 所有权转移
* 对于no-copy type的值，当赋值给一个变量/作为参数传入函数/在函数调用中返回时，不会发生拷贝，而是发生所有权转移
* Python通过引用计数器来赋值，赋值成本低，内存管理成本高。要考虑引用环
* C++通过深拷贝来完成赋值，赋值成本高，但内存管理方便。
* Rust这样设计的好处是赋值成本和内存管理成本都低。而要实现前二者的行为，可以分别用.clone()方法和引用计数指针类型来实现。
## 例子
* 循环和条件语句中转移所有权，后续不能再直接访问该变量了，但可以再对该变量赋新值（而无需声明）
* 在数组中，我们一般取得元素的引用就好，但也可以通过remove(取出并前移)/swap_remove(把末尾换过来)/pop/replace(交换)方法来获取所有权
* std::mem::take函数也可以取出所有权，要求<T>必须是一种具有缺省值的类型，以便留下的位置改为默认值。
* String向量中，一个String和一个空串（被转移所有权后留下默认值空串）的区别并不明显，因此还可以用Option向量来分辨，Some被取走后留下None
* 循环语句也会发生所有权转移，for s in v {}会消费掉v
## Copy Types
* 数字类型、char、bool、元素是copy的数组和元组以及某些类型，是Copy Type。String不是copy type
* 其他用户自定义的数据类型缺省情况下都不是Copy Type，但在满足特定条件时可以声明为Copy Type：如果struct类型所有分量都是copy的，可以通过attribute声明为copy的：#[derive(Copy, Clone)]
## 共享所有权
* 引用计数指针类型Rc/Arc：Rc是线程不安全的，但速度快；Arc是线程安全的，但速度慢。尽量使用Rc，除非编译器提示使用Arc。Rc::new(xxx)和Rc::clone(xx)
* 被Rc拥有的值，不可以修改