# 基础类型
## 基础类型
1. 定宽数字类型
    1. 整数 u/i{8,16,32,64,128}
        * 下划线： 可以对数字进行任意分组
        * 前缀：0x-十六进制、0o-八进制、0b-二进制
        * 后缀：可以在数字后加类型后缀，规定数字类型
        * 不加后缀时，会尝试推断。如果有多于两种可能类型，尽可能假设为i32（可以为i32时选为i32，否则报错）。
        * ASCII字面量： u8类型，可以用【b'字符'】表示，其实也就等价于不加b的'字符'
        * 使用as可以进行整数类型之间的显式转换：变短截断，变长符号填充，无符号数的符号位为0（不论最高位是多少）！
        * 特殊点：函数调用的优先级高于符号（在其他语言中，基础类型一般不存在函数调用，没有这种问题）
        * 算术溢出：在debug模式下程序会终止并输出原因；在release模式下不会监测。但也可以用checked操作符分辨溢出，溢出返回None，未溢出返回Some(num)。None调用expect方法导致panic并输出信息；Some(num)调用expect方法返回num。还可以用wrapping操作符忽视溢出；overflowing操作符把结果和溢出与否包在一起；saturating操作符把溢出结果转换到最近端点。
            ```Rust
            assert!(255_u8.checked_sub(2).wrapping_add(2).overflowing_add(2), (1, true));
            ```
    2. 浮点数 f{32,64}
        * 整数部分必须书写。小数部分、指数部分、类型后缀三者至少存在一种。
        * 下划线： 可以对数字进行任意分组，也可以对后三个部分之间进行分隔。
        * 类型后缀如果没写，会尝试依据上下文推断，如果无法断定，则默认f64
        * 特殊值：f64::MAX/MIN/INFINITY/NEG_INFINITY/NAN
    3. 字长 u/i{size}: 用于表示地址，根据CPU可能是64位或32位
    4. 对不同定宽数字类型，Rust很少主动进行隐式转换（甚至i16到i32也不行），因为隐式转换可能产生bug和安全漏洞。
2. 布尔类型
    * bool的大小为1Byte/8bit，有两个字面量true/false
    * 可以用as转为整数，但整数不能用as转为bool
3. 字符类型
    * char的宽度为4Byte，表示Unicode字符集中的一个字符（实际上Unicode字符只有24bit）
    * 形状字面量：字符放在单引号中，'某'
    * 转义字面量：先写斜杠\，表示一些特殊字符，'\n'
    * ASCII编码字面量：'\xHH'
    * 一般编码字面量：'\u{HHHHHH}'
    * 任何一个u8值都对应一个合法的Unicode编码，可以用as转换为char；一个u32值不一定对应到unicode值，可以用std::char::from_u32尝试转换，返回值可能是None或Some
4. 元组类型
    * 复合类型，0到多个
    * 需要用元组字面量初始化。可以用:( , , )显式指定元组的类型，也可以让编译器自动推断
    * 只能通过常量下标来访问分量
    * 最后一个值可以加一个逗号；一元组唯一的值和唯一的类型后面必须加逗号，以避免歧义；零元组中没有值，零元组只有一个取值即"()"
    * 元组可以作为返回值，可以进一步用字面量来传递
        ```Rust
        fn fun(x:f64, y:f64)->(f64, f64){(x+y, x-y)}
        ```
    * 如果一个地方形式上需要一个值，但内容上不存在值，Rust编译器会自动补上一个零元组。
5. 指针类型
    1. 引用

        &是只读引用，&mut是可变引用，*是去引用。 
        ```Rust
        // 现有两个相等但不同变量的分别引用r1和r2
        assert!(r1==r2);                    // 看穿：引用变量值指向的值（内容）
        assert!(!std::ptr::eq(r1, r2));     // 指针比较：引用变量的内容
        assert!(!std::ptr::eq(&r1, &r2));   // 取址：引用变量的地址（引用变量的引用）
        println!("{}", r1);                 // 看穿
        println!("{}", &r1);                // 看穿
        println!("{:p}", r1);               // 以指针形式打印r1的内容（即r1所指向的地址）
        println!("{:p}", &r1);              // 以指针形式打印&r1的内容（即r1所在的地址）
        ```
    2. Box

        自身是一个指针，把值放在堆中
    3. Raw Pointer
6. 数组，向量，切片
7. 字符串类型

## 
1. size_of函数
获得一个类型的宽度。注意使用方法是
```Rust
use std::mem;
mem::size_of::<i32>;
```